---
title: "Week 2 Lab"
author: "Team Peru"
date: today
format:
  html:
    toc: true
    toc-depth: 2
---

# 0 – Libaries
```{r}
#| label: Libraries
#| message: false
#| warning: false
#| echo: true

library(tidyverse)
library(readxl)
library(countrycode)
library(waldo)
```


# 1 – Country-Level Statistics from the World Bank

## Task 1.1 – Import 2019 Indicators
```{r task1-import}
#| label: task1.1-import
#| message: false

wb_files <- tribble(
  ~file, ~var,
  "data/task1/API_NY.GDP.PCAP.CD_DS2_en_excel_v2_85284.xls", "gdp_per_capita",
  "data/task1/API_SP.DYN.LE00.IN_DS2_en_excel_v2_85119.xls", "life_exp",
  "data/task1/API_SP.POP.TOTL_DS2_en_excel_v2_85347.xls", "pop"
)

read_wb_2019 <- function(path, new_var) {
  read_excel(path, sheet = "Data", skip = 3) |>
    select(code = `Country Code`, !!new_var := `2019`)
}

raw_list   <- map2(wb_files$file, wb_files$var, read_wb_2019)
world_2019 <- reduce(raw_list, left_join, by = "code")

world_2019            # still contains regional aggregates
```

## Task 1.2 – Restrict to Actual Countries
```{r}
#| label: task1.2-filter
#| message: false

country_lookup <- countrycode::codelist |>
  select(code = wb, name = country.name.en, continent)

world_countries <- world_2019 |>
  inner_join(country_lookup, by = "code") |>
  arrange(name)

nrow(world_countries)   # count after dropping aggregates
```

## Task 1.3 – Add Continent Info
```{r}
#| label: task1.3-continent
#| message: false
world_countries <- world_countries |>
  relocate(name, code, continent)

glimpse(world_countries)
```

## Task 1.4 – Format Data Frame
```{r}
#| label: task1.4-format
#| message: false

# 0 Get the official World Bank country names from the GDP sheet
wb_names <- read_excel(
  "data/task1/API_NY.GDP.PCAP.CD_DS2_en_excel_v2_85284.xls",
  sheet = "Data",
  skip  = 3
) |>
  select(code = `Country Code`,
         name = `Country Name`)

# 1 Bring continent + indicators together
world_formatted <- world_countries |>
  select(-name) |>                       # discard codelist name
  left_join(wb_names, by = "code") |>    # add WB‑official name
  relocate(name, code, continent) |>
  transmute(                             # keep / rename columns
    name,
    code,
    gdp_per_cap = gdp_per_capita,
    life_exp,
    pop,
    continent
  ) |>
  drop_na() |>                           # remove any remaining NAs
  filter(!code %in% c("CHI", "XKX")) |>  # drop Channel Islands & Kosovo
  arrange(name)                          # alphabetical

nrow(world_formatted)                    # prints 209
world_formatted
```

## Task 1.5 – No Missing Data & Reference Check
```{r}
#| label: task1.5-validate
#| message: false

# 1 Ensure there are no NAs left
sum(is.na(world_formatted))        # expect 0

# 2 Load reference file and compare
world_ref <- read_csv("data/reference/country_profiles_2019.csv", show_col_types = FALSE)

waldo::compare(
  world_formatted,
  world_ref,
  tolerance = 1e-12
)
```

# 2 – Population Statistics for Singapore

## Task 2.1 – Import data

Below we read the header row (A11:BQ11) to grab the years, then read rows 37–86 and assign those names.
```{r}
#| label: task2.1-import
#| message: false

# point to the SingStat file
xlsx_file <- file.path("data", "task2", "outputFile.xlsx")

# 1. Read the header row (A11:BQ11) without names
year_header <- read_excel(
  xlsx_file,
  sheet     = "T4",
  range     = "A11:BQ11",
  col_names = FALSE
)

# 2. Build column names: first "age_group", then the years
col_names <- c(
  "age_group",
  as.character(unlist(year_header[1, -1]))
)

# 3. Read the data block (rows 37–86) without names
sg_raw <- read_excel(
  xlsx_file,
  sheet     = "T4",
  range     = "A37:BQ86",
  col_names = FALSE
)

# 4. Assign the extracted names
colnames(sg_raw) <- col_names

# 5. Inspect the first few rows
head(sg_raw)
sg_raw
```

## Task 2.15 – Testing
```{r task2.15-testing, message=FALSE}
#| label: task2.15-testing

library(readxl)
library(dplyr)
library(tidyr)
library(stringr)

# --- Import Data ---
year_header <- read_excel(
  "data/task2/outputFile.xlsx",
  sheet     = "T4",
  range     = "A11:BQ11",
  col_names = FALSE
)
sg_raw <- read_excel(
  "data/task2/outputFile.xlsx",
  sheet     = "T4",
  range     = "A37:BQ86",
  col_names = FALSE
)

# --- Data Parsing ---
# Drop "Data Series" in header
years <- as.character(as.numeric(year_header[1, -1]))

# Find where female block starts
female_start <- which(sg_raw[[1]] == "Total Female Residents")

# Split into male_raw and female_raw
male_raw   <- sg_raw[1:(female_start - 1), ]
female_raw <- sg_raw[female_start:nrow(sg_raw), ]

# Assign column names: age_group + years
colnames(male_raw)   <- c("age_group", years)
colnames(female_raw) <- c("age_group", years)

# Preview raw blocks
head(male_raw, 5)
head(female_raw, 5)

# --- Reshape Data ---
# Tidy Male
male_long <- male_raw %>%
  mutate(across(everything(), as.character)) %>%
  pivot_longer(
    cols      = -1,
    names_to  = "year",
    values_to = "pop"
  ) %>%
  rename(age_group = 1) %>%
  mutate(
    sex = factor("Male", levels = c("Male", "Female")),
    year = as.numeric(year),
    pop  = as.numeric(gsub(",", "", pop))
  )

# Tidy Female
female_long <- female_raw %>%
  mutate(across(everything(), as.character)) %>%
  pivot_longer(
    cols      = -1,
    names_to  = "year",
    values_to = "pop"
  ) %>%
  rename(age_group = 1) %>%
  mutate(
    sex = factor("Female", levels = c("Male", "Female")),
    year = as.numeric(year),
    pop  = as.numeric(gsub(",", "", pop))
  )

# Combine and clean
sg_long <- bind_rows(male_long, female_long) %>%
  filter(!str_detect(age_group, "Total"))

# Final preview
sg_long
```

## Task 2.2 – Restrict to relevant years

We pivot the data into long form, convert `year` to integer, and keep only the decadal years.
```{r task2.2-filter}
#| label: task2.2-filter
#| message: false

sg_filtered <- sg_long %>%
  filter(year %% 10 == 0, year >= 1960, year <= 2020)

# Preview filtered years
sg_filtered
```

## Task 2.3 – Infer the oldest cohort size
```{r task2.3-parse}
#| label: task2.3-parse
#| message: false

sg_parsed <- sg_filtered %>%
  mutate(
    age_group = str_trim(age_group),  # remove extra whitespace
    age = case_when(
      str_detect(age_group, "Under 1")       ~ 0,
      str_detect(age_group, "1 - 4")         ~ 1,
      str_detect(age_group, "\\d+ - \\d+")   ~ as.numeric(str_extract(age_group, "^\\d+")),
      str_detect(age_group, "\\d+ Years & Over") ~ as.numeric(str_extract(age_group, "^\\d+")),
      TRUE                                   ~ NA_real_
    )
  ) %>%
  filter(!str_detect(age_group, "^Total")) %>%  # drop any "Total ..." rows
  drop_na(age, pop)

sg_parsed_deduped <- sg_parsed %>%
  distinct(age, sex, year, .keep_all = TRUE) %>%
  arrange(age, sex, year)

# Preview the first few rows
head(sg_parsed_deduped, 10)
sg_parsed_deduped
```

## Task 2.4 – Format Data
```{r task2.4-format, message=FALSE}
#| label: task2.4-format

sg_final <- sg_parsed_deduped %>%
  select(age, sex, year, pop) %>%
  arrange(age, sex, year)

sg_final
```

## Task 2.5 – No Missing Data & Reference Check

Remove any rows containing `NA`, then compare your result to the provided `sg_5yr_cohorts.csv`.
```{r task2.5-validate}
#| label: task2.5-validate
#| message: false

# 1. Drop any rows with missing values
sg_clean <- sg_final %>%
  drop_na()

# 2. Load reference file, setting sex as a factor with the correct levels
sg_ref <- read_csv(
  "data/reference/sg_5yr_cohorts.csv",
  col_types = cols(sex = col_factor(levels = c("Male", "Female")))
)

# 3. Compare — should return "No differences"
waldo::compare(sg_clean, sg_ref, tolerance = 1e-12)
```
# 3 – Reflections